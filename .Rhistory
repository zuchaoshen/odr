if (par$a * par$b > 0){
if (0 < unname(mcci)[1]){
pwr = 1
} else {
pwr = 0
}
} else{
if (0 > unname(mcci)[2]){
pwr = 1
} else {
pwr = 0
}
}
return(pwr)
} else {
if (par$a * par$b > 0) {
mcci <- quantile(aabb, sig.level)
if (0 < unname(mcci)){pwr = 1} else {pwr = 0}
} else {
mcci <- quantile(aabb, 1 - sig.level)
if (0 > unname(mcci)){pwr = 1} else {pwr = 0}
}
return(pwr)
}
}
pwr.function <- function(p, n){
pwr.mcci <- mean(replicate(n.rep, pwr.mc(p, n), simplify = TRUE))
return(pwr.mcci)
}
#
n.of.initial <- round(sqrt(n.of.archive), 0)
n.initial <- seq(from = d.n[1], to = d.n[2], length = n.of.initial)
p.initial <- seq(from = d.p[1], to = d.p[2], length = n.of.initial)
n.of.archive <- n.of.initial^2
nl <- matrix(NA, n.of.archive, n.of.archive-1)
X <- NULL
p.X <- NULL
y <- NULL
pwr <- NULL
achv <- pp <- data.frame(v = numeric(), sd = numeric(), gr = numeric(),
p = numeric(), n = numeric(), pwr =  numeric());
X <- p.X <- cbind(rep(p.initial, length(n.initial)),
rep(n.initial, each = length(p.initial)))
pwr <- y <- mapply(pwr.function,
p = X[, 1], n = X[, 2], SIMPLIFY = TRUE)
# for (n in n.initial){
#   for (p in p.initial){
#     X <- rbind(X, c(p, n))
#     p.X <- rbind(p.X, c(p, n))
#     sd.a <- eval(sd.a.expr)
#     sd.b <- eval(sd.b.expr)
#     pwr.mcci <- mean(replicate(1000, pwr.function(two.tailed, sig.level,
#                                a, b, sd.a, sd.b, n, p, m), simplify = TRUE))
#     y <- c(y, pwr.mcci)
#     pwr <- c(pwr, pwr.mcci)
#   }
# }
pp <- rbind(pp, data.frame(v = y, sd = 0, gr = 0,
p = X[,1], n = X[, 2], pwr = pwr))
achv <- rbind(achv, data.frame(v = y, sd = 0, gr = 0,
p = X[,1], n = X[, 2], pwr = pwr))
pp$gr <- rank(-pp$v, ties.method = "random")
for (i in 1:n.of.archive){
nl[i,] <- (1:n.of.archive)[1:n.of.archive!=i]
}
#  colnames(p.X) <- c("p", "n")
#  colnames(X) <- c("p", "n")
#  p.X <- as.data.frame(p.X)
n.iter <- n.of.archive
if (verbose)
{cat('The ACO algorithm finished initilization of ', n.of.archive, ' analyses',".\n", sep = "")}
while (TRUE) { # the algorithm will stop if one of the stop criteria is met
dist.mean <- p.X
# the algorithm will stop if it converges (no more change in optimal design parameter values)
if (sum(apply(dist.mean, 2, stats::sd)) == 0) {
return(list(archive = achv, archive.design.pars = p.X, n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(power = max.y, p = max.X[1], n = max.X[2])))
}
dist.rank <- pp$gr
dim(dist.mean) <- c(length(pp$v), n.of.opt.pars)
o.X <- vector()
o.X <- gen.design.pars(dist.mean, dist.rank, n.of.ants, nl, q, n.of.archive, xi)
# the algorithm will stop if it converges (no more available random samples)
if (length(o.X) == 0) {
return(list(archive = achv, archive.design.pars = p.X, n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(power = max.y, p = max.X[1], n = max.X[2])))
}
#X <- o.X
X <- NULL
for (i in 1:n.of.ants){ # exclude unreasonable values
if (sum((0.001 < o.X[i, 1] & o.X[i, 1] < 0.999),
(0.3 < o.X[i, 2]  && o.X[i, 2] < 10000)) == n.of.opt.pars) {
X <- rbind(X, o.X[i,])
}
}
if(length(X)>0) {
p.X <- rbind(p.X, X)
dim(X) <- c(length(X)/n.of.opt.pars, n.of.opt.pars)
pwr <- mapply(pwr.function, p = X[, 1], n = X[, 2], SIMPLIFY = TRUE)
y <- c(y, pwr)
pp <- rbind(pp, data.frame(v = pwr, sd = 0, gr = 0,
p = X[,1], n = X[, 2], pwr = pwr))
achv <- rbind(achv, data.frame(v = pwr, sd = 0, gr = 0,
p = X[,1], n = X[, 2], pwr = pwr))
n.iter <- n.iter + dim(X)[1]
if (verbose) {cat('Number of tried evaluations is ', n.iter, ".\n", sep = "")}
#            for (j in 1:dim(X)[1]) { # redo power analysis with n.of.ants times for those reasonable
#
#              n.iter <- n.iter + 1
#              p <- X[j, 1]
#              n <- X[j, 2]
#              if (verbose) {cat('Number of tried evaluations is ', n.iter, ".\n", sep = "")}
#              X <- rbind(X, c(p, n))
#              p.X <- rbind(p.X, c(p, n))
# #             sd.a <- eval(sd.a.expr)
# #             sd.b <- eval(sd.b.expr)
#              pwr.mcci <-  pwr.mc(p, n)
#              y <- c(y, pwr.mcci)
#              pwr <- c(pwr, pwr.mcci)
#
#            }
}
# recalculate the rank
pp$gr <- rank(-pp$v, ties.method = "random") # calculate the rank of the solutions
idx.final <- pp$gr <= n.of.archive
pp <- pp[idx.final,]
p.X <- p.X[idx.final,]
y <- y[idx.final]
dim(p.X) <- c(length(p.X)/n.of.opt.pars, n.of.opt.pars)
for (i in 1:n.of.archive) {nl[i,] <- (1:n.of.archive)[1:n.of.archive!=i]}
# check if the required accuracy have been obtained
if (max(y, na.rm = TRUE) > max.y) {
max.y <- max(y, na.rm = TRUE)
max.X <- p.X[which.max(y), ]
# colnames(max.X) <- c(phan.names, "eval")
last.impr <- eval}
if ((abs(max.y - max.value) < abs(e.rel * max.value + e.abs)) |
(max.y > max.value)) {
return(list(archive = achv, archive.design.pars = p.X, n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(power = max.y, p = max.X[1], n = max.X[2])))
}
# check if the maximum allowed number of objective function
# evaluations has not been exceeded
if (n.iter >= max.iter) {
return(list(archive = achv, archive.design.pars = p.X, n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(power = max.y, p = max.X[1], n = max.X[2])))
}
}
} else if (is.null(par$n) & !is.null(par$p)){
} else if (!is.null(par$n) & is.null(par$p)) {
} else if (!is.null(par$n) & !is.null(par$p)) {
cat("===============================\n",
"There is no calculation performed
because both p and n are contrained",
".\n===============================\n", sep = "")
return(list(par = par, funName = funName,
designType = designType,
out = c(p = par$p, n = par$n)))
}
}
}
#' Generate optimal design parameters using ant colony optimization
#'
#' @description This function can generate a set of optimal design parameters
#'     based on given distributions of the rank of optimization target
#'     (or budget).
#'
#' @inheritParams od.2.221m
#' @param dist.mean List of means - coordinates
#' @param dist.rank Rank of the archived values of objective function
#' @param nl Neighborhood of the search area
#' @return
#'     Generated optimal design parameter value(s) (i.e., a matrix with n.of.ants
#'     rows and n.of.design.pars columns)
#'
#' @export gen.design.pars
#
#' @references
#'
#'   Socha, K., & Dorigo, M. (2008). Ant colony optimization for
#'   continuous domains. European Journal of Operational Research,
#'   185(3), 1155-1173.
#'
#'   We thank Dr. Krzysztof Socha for providing us the
#'   original code (http://iridia.ulb.ac.be/supp/IridiaSupp2008-001/)
#'   for this function.
#'
#' @examples
#'
#' k <- 50 # size of archive
#' # Generate dist.mean and dist.rank
#' dist.mean <- cbind(rnorm(n.of.archive),
#' rnorm(n.of.archive), rnorm(n.of.archive), rnorm(n.of.archive), rnorm(n.of.archive))
#' y <- rowMeans(dist.mean)
#' dist.rank <- rank(-y, ties.method = "random")
#' # set up neighborhood
#' nl <- matrix(NA, n.of.archive, n.of.archive-1)
#' for (i in 1:n.of.archive){
#'   nl[i,] <- (1:n.of.archive)[1:n.of.archive != i]
#'  }
#' my.design.pars <- gen.design.pars(dist.mean, dist.rank, n.of.ants = 10,
#'                               nl, q = 0.0001, n.of.archive =50, xi = 0.50)
#' my.design.pars
#'
gen.design.pars <- function(dist.mean, dist.rank, n.of.ants, nl,
q = 0.0001, n.of.archive = 100, xi = 0.50) {
euc.dist <- function(d) { # Euclidean distance
return(sqrt(sum(d^2)))
}
X <- array(dim = c(n.of.ants, dim(dist.mean)[2]))
idx <- sample(dim(dist.mean)[1], size = n.of.ants,
replace = TRUE, prob = stats::dnorm(dist.rank, 1, q*n.of.archive))
# iterate through the chosen distributions
for (l in 1:length(idx)) {
j <- idx[l]
# rotate the coordinate system
o.dist.mean <- t(t(dist.mean) - dist.mean[j,])  # translation of origin
r.dist.mean <- o.dist.mean
set <- nl[j,]  # set of available neighbors
vec <- vector()
for (m in 1:(dim(dist.mean)[2]-1)) {
dis <- apply(matrix(r.dist.mean[set,m:dim(r.dist.mean)[2]],
length(set),length(m:dim(r.dist.mean)[2])),1, euc.dist)
if (sum(dis)==0.0)  return(NULL) # if the distribution have converged
if (length(set)>1){ ## ADDED bracket
choice <- sample(set,size=1,prob=dis^4)
} else { ## ADDED bracket
choice <- set
}
vec <- cbind(vec,o.dist.mean[choice,])
R <- qr.Q(qr(vec), complete=TRUE) # rot. matrix after orthogonalization
if (det(R)<0) {
R[,1] <- -R[,1]
}
r.dist.mean <-  o.dist.mean %*% R # rotated coordinates
set <- set[set!=choice]
}
dist.sd <- vector()
for (i in 1:dim(dist.mean)[2]) {
dist.sd <- c(dist.sd,sum(abs(r.dist.mean[nl[j,],i]-
r.dist.mean[j,i]))/(n.of.archive-1))
}
n.x <- stats::rnorm(dim(dist.mean)[2],r.dist.mean[j,],dist.sd*xi)
n.x <- R %*% n.x
n.x <- t(n.x + dist.mean[j,])
X[l,] <- n.x
}
return(X)
}
# Illustration
setwd("D:\\Dropbox\\1Publication\\2021 ACO for OD\\2021 JXE ACO for optimal design\\R code")
library(lme4) # Multilevel modeling
library(psych) # descriptive analysis
library(dplyr) # data manipulation and missing values
library(tidyr) # data manipulation and missing values
library(naniar) # missing code
library(xlsx) # write excel sheet
library(readxl) # read excel
set.seed(123)
start.time <- proc.time()
my.od<- od.2.221(a = 0.3, b = 0.3, cp = 0.1, icc = 0.2,
c1 = 1, c1t = 1, c2 = 10, c2t = 50, m = 5200,
r2m = 0, r12 = 0.3, r22 = .5,
q.a = 0, q.b = 0,
test = "mcci",
n = NULL, p = NULL, iter = 100,
tol = 1e-11, power.joint = 0.80,
d.p = c(0.1, 0.5), d.n = c(4, 50),
sig.level = 0.05, two.tailed = TRUE,
plots = TRUE, plot.by = NULL,
nlim = c(0, 50), plim = c(0, 1), varlim = c(0, 0.05),
Jlim = c(4, 10e4),
nlab = NULL, plab = NULL, varlab = NULL,
vartitle = NULL,verbose = TRUE,
max.value = Inf, max.iter = 150,  e = 1e-10,
n.of.ants = 5, n.of.archive = 50, q = 0.0001,
xi = 0.5)
my.od$archive[1:150,]
my.od$out
proc.time() - start.time
start.time <- proc.time()
my.od<- od.2.221(a = 0.3, b = 0.3, cp = 0.1, icc = 0.2,
c1 = 1, c1t = 1, c2 = 10, c2t = 50, m = 4500,
r2m = 0, r12 = 0.3, r22 = .5,
q.a = 0, q.b = 0,
test = "mcci",
n = NULL, p = NULL, iter = 100,
tol = 1e-11, power.joint = 0.80,
d.p = c(0.1, 0.5), d.n = c(4, 50),
sig.level = 0.05, two.tailed = TRUE,
plots = TRUE, plot.by = NULL,
nlim = c(0, 50), plim = c(0, 1), varlim = c(0, 0.05),
Jlim = c(4, 10e4),
nlab = NULL, plab = NULL, varlab = NULL,
vartitle = NULL,verbose = TRUE,
max.value = Inf, max.iter = 150,  e = 1e-10,
n.of.ants = 5, n.of.archive = 50, q = 0.0001,
xi = 0.5)
my.od$archive[1:150,]
my.od$out
proc.time() - start.time
start.time <- proc.time()
my.od<- od.2.221(a = 0.3, b = 0.3, cp = 0.1, icc = 0.2,
c1 = 1, c1t = 1, c2 = 10, c2t = 50, m = 4900,
r2m = 0, r12 = 0.3, r22 = .5,
q.a = 0, q.b = 0,
test = "mcci",
n = NULL, p = NULL, iter = 100,
tol = 1e-11, power.joint = 0.80,
d.p = c(0.1, 0.5), d.n = c(4, 50),
sig.level = 0.05, two.tailed = TRUE,
plots = TRUE, plot.by = NULL,
nlim = c(0, 50), plim = c(0, 1), varlim = c(0, 0.05),
Jlim = c(4, 10e4),
nlab = NULL, plab = NULL, varlab = NULL,
vartitle = NULL,verbose = TRUE,
max.value = Inf, max.iter = 150,  e = 1e-10,
n.of.ants = 5, n.of.archive = 50, q = 0.0001,
xi = 0.5)
my.od$archive[1:150,]
my.od$out
proc.time() - start.time
power = my.od$out$power # .811
pp = my.od$out$p #.3172
nn = my.od$out$n # 2.165
my.od$out$power # .811
my.od$out$p #.3172
my.od$out$n # 2.165
n=nn
p = pp
J = m/((n*c1t+c2t)*p+(1-p)*(n*c1+c2));J # 215.2642
m = my.od$par$m
J = m/((n*c1t+c2t)*p+(1-p)*(n*c1+c2));J # 215.2642
nn = my.od$out$n # .5614
c1 = my.od$par$c1
c1t = my.od$par$c1t
c2 = my.od$par$c2
c2t = my.od$par$c2t
m = my.od$par$m
n=nn
p = pp
J = m/((n*c1t+c2t)*p+(1-p)*(n*c1+c2));J # 215.2642
# Power under Monte Carlo confidence interval test for two-tailed test
sd.a.expr <- quote({J <- m/(p * (c1t * n + c2t) + (1 - p)  *(c1*n + c2));
sqrt(1/(p * (1 - p) *J))})
# Power under Monte Carlo confidence interval test for two-tailed test
sd.a.expr <- quote({J <- m/(p * (c1t * n + c2t) + (1 - p)  *(c1*n + c2));
sqrt(1/(p * (1 - p) *J))})
sd.b.expr <- quote({J <- m/(p * (c1t * n + c2t) + (1 - p)  *(c1*n + c2));
sqrt((icc - b^2 + (1 - icc) / n) /
(J ))})
pwr.function <- function(#two.tailed, sig.level,
#a, b, sd.a, sd.b,
p, n#, m
){
pwr.mc <- function(p, n){
if (two.tailed){
#J <- m/(p * (c1t * n + c2t) + (1 - p)  *(c1*n + c2))
aa <- rnorm(1000, mean = a, sd = eval(sd.a.expr))
bb <- rnorm(1000, mean = b, sd = eval(sd.b.expr))
aabb <- aa*bb
mcci <- quantile(aabb, c(sig.level/2, 1-sig.level/2))
if (a * b > 0){
if (0 < unname(mcci)[1]){
pwr = 1
} else {
pwr = 0
}
} else{
if (0 > unname(mcci)[2]){
pwr = 1
} else {
pwr = 0
}
}
return(pwr)
} else {
#J <- m/(p * (c1t * n + c2t) + (1 - p)  *(c1*n + c2))
aa <- rnorm(1000, mean = a, sd = eval(sd.a.expr))
bb <- rnorm(1000, mean = b, sd = eval(sd.b.expr))
aabb <- aa*bb
if (a * b > 0) {
mcci <- quantile(aabb, sig.level)
if (0 < unname(mcci)){pwr = 1} else {pwr = 0}
} else {
mcci <- quantile(aabb, 1 - sig.level)
if (0 > unname(mcci)){pwr = 1} else {pwr = 0}
}
return(pwr)
}
}
pwr.mcci <- mean(replicate(n.rep, pwr.mc(p, n), simplify = TRUE))
return(pwr.mcci)
}
### ===== for first condition
a = 0.3; b = 0.3; cp = 0.1; icc = 0.2;
c1 = 1; c1t = 1; c2 = 10; c2t = 50; m = 5350;
r2m = 0; r12 = 0.3; r22 = .5;
q.a = 0; q.b = 0;
test = "mcci"; n.rep = 1000;
#n = NULL; p = NULL;
iter = 100;
tol = 1e-11; power.joint = 0.80; power.mcci = 0.80;
### ===== for first condition
a = 0.3; b = 0.3; cp = 0.1; icc = 0.2;
c1 = 1; c1t = 1; c2 = 10; c2t = 50; m = 4900;
r2m = 0; r12 = 0.3; r22 = .5;
q.a = 0; q.b = 0;
test = "mcci"; n.rep = 1000;
#n = NULL; p = NULL;
iter = 100;
tol = 1e-11; power.joint = 0.80; power.mcci = 0.80;
d.p = c(0.1, 0.5); d.n = c(4, 50);
sig.level = 0.05; two.tailed = TRUE;
plots = TRUE; plot.by = NULL;
nlim = c(0, 50); plim = c(0, 1); varlim = c(0, 0.05);
Jlim = c(4, 10e4);
nlab = NULL; plab = NULL; varlab = NULL;
vartitle = NULL;verbose = TRUE;
max.value = Inf; max.iter = 300;  e = 1e-10;
n.of.ants = 5; n.of.archive = 150; q = 0.0001;
xi = 0.5
n=nn
p = pp
J = m/((n*c1t+c2t)*p+(1-p)*(n*c1+c2));J
plim = c(0, 1)
nlim = c(1, 50)
nrange <- seq(nlim[1], nlim[2], by = 0.5)
prange <- seq(plim[1] + 0.02, plim[2] - 0.02, by = 0.01)
# MCCI power plot by n
pwr.mcci <- NULL
for (n in nrange){
pwr.mcci <- c(pwr.mcci, pwr.function(p, n))
}
par(mfrow = c (1, 1))
plot.y <- pwr.mcci
#png("power.a.n.png", width = 300, height = 300)
plot(nrange, plot.y,
type = "l", lty = 1,
xlim = c(0, 50), ylim = c(0, 1),
xlab = "Individual-Level Sample Size: n", ylab = "Power",
main = "(a)",
col = "black")
graphics::abline(v = nn, lty = nn, col = "black")
n =nn
p = pp
# MCCI power plot by p
pwr.mcci <- NULL
for (p in prange){
pwr.mcci <- c(pwr.mcci, pwr.function(p, n))
}
n = nn
p = pp
J = m/((n*c1t+c2t)*p+(1-p)*(n*c1+c2));J
par(mfrow = c (1, 1))
#png("power.b.p.png", width = 300, height = 300)
plot.y <- pwr.mcci
graphics::plot(prange, plot.y,
type = "l", lty = 1,
xlim = c(0.2, .6), ylim = c(0, 1),
xlab = "Proportion in Treatment: p", ylab = "Power",
main = "(b)",
col = "black")
graphics::abline(v = pp, lty = 2, col = "black")
dev.off()
#png("power.b.p.png", width = 300, height = 300)
plot.y <- pwr.mcci
graphics::plot(prange, plot.y,
type = "l", lty = 1,
xlim = c(0.2, .6), ylim = c(0, 1),
xlab = "Proportion in Treatment: p", ylab = "Power",
main = "(b)",
col = "black")
graphics::abline(v = pp, lty = 2, col = "black")
m
m
J
setwd("D:\\Dropbox\\odr")
##############
#########################################################
getwd()
setwd("D:\\Dropbox\\odr")
devtools::document()
devtools::document()
setwd("D:\\Dropbox\\odr")
devtools::document()
#library(devtools)
#########################################################
devtools::spell_check() # spell check
install.packages("Rcpp")
install.packages("Rcpp")
#library(devtools)
#########################################################
devtools::spell_check() # spell check
#library(devtools)
#########################################################
devtools::spell_check() # spell check
devtools::check_rhub() # rhub check
devtools::check_rhub() # rhub check
devtools::check_win_devel() # check on win-builder (with `check_win_devel()`)?
devtools::check_rhub() # rhub check
library(odr)
library(odr)
devtools::document()
devtools::document()
devtools::check_win_devel() # check on win-builder (with `check_win_devel()`)?
devtools::check_rhub() # rhub check
devtools::release() # submit to CRAN
