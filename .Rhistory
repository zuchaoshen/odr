m <- max(m, m.m)
y <- c(y, 1/m)
budget <- c(budget, m)
}
}
pp <- rbind(pp, data.frame(v = y, sd = 0, gr = 0, m = budget))
pp$gr <- rank(-pp$v, ties.method = "random")
for (i in 1:n.of.archive){
nl[i,] <- (1:n.of.archive)[1:n.of.archive!=i]
}
n.iter <- n.of.archive
if (verbose)
{cat('The ACO algorithm finished initilization of ', n.of.archive,
' analyses',".\n", sep = "")}
while (TRUE) { # the algorithm will stop if one of the criteria is met
dist.mean <- p.X
# the algorithm will stop if it converges
if (sum(apply(dist.mean, 2, stats::sd)) < e) {
m = 1/max.y; p = max.X[1]; n = max.X[2];
J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- c("p", "n");
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
dist.rank <- pp$gr
dim(dist.mean) <- c(length(pp$v), n.of.opt.pars)
o.X <- vector()
o.X <- gen.design.pars(dist.mean, dist.rank, n.of.ants,
nl, q.aco, n.of.archive, xi)
if (length(o.X) == 0) {
m = 1/max.y; p = max.X[1]; n = max.X[2];
J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- c("p", "n");
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
X <- NULL
for (i in 1:n.of.ants){ # exclude unreasonable values
if (sum((0.001 < o.X[i, 1] & o.X[i, 1] < 0.999),
(nrange[1] < o.X[i, 2]  && o.X[i, 2] < nrange[2])) == n.of.opt.pars) {
X <- rbind(X, o.X[i,])
}
}
if(length(X)>0) {
p.X <- rbind(p.X, X)
dim(X) <- c(length(X)/n.of.opt.pars, n.of.opt.pars)
for (j in 1:dim(X)[1]) {
# redo power analysis with n.of.ants times for those reasonable
n.iter <- n.iter + 1
p <- X[j, 1]
n <- X[j, 2]
if (verbose) {
if(n.iter==n.of.archive+1){
cat('The number of iterations is ', n.iter, sep = "")
}else if((n.iter>n.of.archive+1)&(n.iter < max.iter)){
if (n.iter %in% c(seq(100, max.iter, by=100), max.iter)){
cat(n.iter,
" ", sep = "")
}else{
cat(".", sep = "")
}
}
}
J <- stats::uniroot(function(J)
eval(pwr.expr) - power, Jlim)$root
m <- J *((1 - p) * c1 * n + p * c1t * n + c2)
J.m <- stats::uniroot(function(J)
eval(pwr2.expr) - (power-power.dis), Jlim)$root
m.m <- J.m *((1 - p) * c1 * n + p * c1t * n + c2)
m <- max(m, m.m)
y <- c(y, 1/m)
budget <- c(budget, m)
pp <- rbind(pp, data.frame(v = 1/m, sd = 0, gr = 0, m = m))
}
}
# recalculate the rank
pp$gr <- rank(-pp$v, ties.method = "random")
idx.final <- pp$gr <= n.of.archive
pp <- pp[idx.final,]
p.X <- p.X[idx.final,]
y <- y[idx.final]
dim(p.X) <- c(length(p.X)/n.of.opt.pars, n.of.opt.pars)
for (i in 1:n.of.archive)
{nl[i,] <- (1:n.of.archive)[1:n.of.archive!=i]}
# check if the required accuracy have been obtained
if (max(y, na.rm = TRUE) > max.y) {
max.y <- max(y, na.rm = TRUE)
max.X <- p.X[which.max(y), ]
last.impr <- eval}
if ((abs(max.y - max.value) < abs(e.rel * max.value + e.abs)) |
(max.y > max.value)) {
m = 1/max.y; p = max.X[1]; n = max.X[2];
J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- c("p", "n");
return(list(archive = pp, archive.design.pars = p.X,
archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
# check if the maximum allowed number of objective function
# evaluations has not been exceeded
if (n.iter >= max.iter) {
m = 1/max.y; p = max.X[1]; n = max.X[2];
J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- c("p", "n");
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
}
} else if (!is.null(par$n) & is.null(par$p)){
n.of.opt.pars <- 1
if (verbose) {cat('The ACO algorithm started initilization..',
".\n", sep = "")}
e.abs <- e # absolute error
e.rel <- e # relative error
last.impr <- max.iter
design.pars <- data.frame()
outcome <- vector()
max.X <- rep(NA, n.of.opt.pars)
max.y <- -Inf
p.X <- vector()
pp <- data.frame(v = numeric(), sd = numeric(), gr = numeric());
outcome <- NULL
n.of.initial <- round(n.of.archive, 0)
p.initial <- seq(from = d.p[1], to = d.p[2], length = n.of.initial)
n.of.archive <- n.of.initial
nl <- matrix(NA, n.of.archive, n.of.archive-1)
X <- NULL
p.X <- NULL
y <- NULL
budget <- NULL
for (p in p.initial){
X <- rbind(X, p)
p.X <- rbind(p.X, p)
J <- stats::uniroot(function(J)
eval(pwr.expr) - power, Jlim)$root
m <- J *((1 - p) * c1 * n + p * c1t * n + c2)
J.m <- stats::uniroot(function(J)
eval(pwr2.expr) - (power-power.dis), Jlim)$root
m.m <- J.m *((1 - p) * c1 * n + p * c1t * n + c2)
m <- max(m, m.m)
y <- c(y, 1/m)
budget <- c(budget, m)
}
pp <- rbind(pp, data.frame(v = y, sd = 0, gr = 0, m = budget))
pp$gr <- rank(-pp$v, ties.method = "random")
for (i in 1:n.of.archive){
nl[i,] <- (1:n.of.archive)[1:n.of.archive!=i]
}
n.iter <- n.of.archive
if (verbose)
{cat('The ACO algorithm finished initilization of ', n.of.archive,
' analyses',".\n", sep = "")}
while (TRUE) { # the algorithm will stop if one of the criteria is met
dist.mean <- p.X
# the algorithm will stop if it converges
if (sum(apply(dist.mean, 2, stats::sd)) < e) {
m = 1/max.y; p = max.X;
n = par$n; J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- "p";
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
dist.rank <- pp$gr
dim(dist.mean) <- c(length(pp$v), n.of.opt.pars)
o.X <- vector()
o.X <- gen.design.pars(dist.mean, dist.rank,
n.of.ants, nl, q.aco, n.of.archive, xi)
if (length(o.X) == 0) {
m = 1/max.y; p = max.X;
n = par$n; J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- "p";
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
X <- NULL
for (i in 1:n.of.ants){ # exclude unreasonable values
if (sum((0.001 < o.X[i, 1] & o.X[i, 1] < 0.999)) == n.of.opt.pars) {
X <- rbind(X, o.X[i,])
}
}
if(length(X)>0) {
p.X <- rbind(p.X, X)
dim(X) <- c(length(X)/n.of.opt.pars, n.of.opt.pars)
for (j in 1:dim(X)[1]) {
# redo power analysis with n.of.ants times for those reasonable
n.iter <- n.iter + 1
p <- X[j, 1]
if (verbose) {
if(n.iter==n.of.archive+1){
cat('The number of iterations is ', n.iter, sep = "")
}else if((n.iter>n.of.archive+1)&(n.iter < max.iter)){
if (n.iter %in% c(seq(100, max.iter, by=100), max.iter)){
cat(n.iter,
" ", sep = "")
}else{
cat(".", sep = "")
}
}
}
J <- stats::uniroot(function(J)
eval(pwr.expr) - power, Jlim)$root
m <- J *((1 - p) * c1 * n + p * c1t * n + c2)
J.m <- stats::uniroot(function(J)
eval(pwr2.expr) - (power-power.dis), Jlim)$root
m.m <- J.m *((1 - p) * c1 * n + p * c1t * n + c2)
m <- max(m, m.m)
y <- c(y, 1/m)
budget <- c(budget, m)
pp <- rbind(pp, data.frame(v = 1/m, sd = 0, gr = 0, m = m))
}
}
# recalculate the rank
pp$gr <- rank(-pp$v, ties.method = "random")
idx.final <- pp$gr <= n.of.archive
pp <- pp[idx.final,]
p.X <- p.X[idx.final,]
y <- y[idx.final]
dim(p.X) <- c(length(p.X)/n.of.opt.pars, n.of.opt.pars)
for (i in 1:n.of.archive)
{nl[i,] <- (1:n.of.archive)[1:n.of.archive!=i]}
# check if the required accuracy have been obtained
if (max(y, na.rm = TRUE) > max.y) {
max.y <- max(y, na.rm = TRUE)
max.X <- p.X[which.max(y), ]
last.impr <- eval}
if ((abs(max.y - max.value) < abs(e.rel * max.value + e.abs)) |
(max.y > max.value)) {
m = 1/max.y; p = max.X;
n = par$n; J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- "p";
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
# check if the maximum allowed number of objective function
# evaluations has not been exceeded
if (n.iter >= max.iter) {
m = 1/max.y; p = max.X;
n = par$n; J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- "p";
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
}
} else if (is.null(par$n) & !is.null(par$p)){
n.of.opt.pars <- 1
if (verbose) {cat('The ACO algorithm started initilization..',
".\n", sep = "")}
e.abs <- e # absolute error
e.rel <- e # relative error
last.impr <- max.iter
design.pars <- data.frame()
outcome <- vector()
max.X <- rep(NA, n.of.opt.pars)
max.y <- -Inf
p.X <- vector()
pp <- data.frame(v = numeric(), sd = numeric(), gr = numeric());
outcome <- NULL
n.of.initial <- round(n.of.archive, 0)
n.initial <- seq(from = d.n[1], to = d.n[2], length = n.of.initial)
n.of.archive <- n.of.initial
nl <- matrix(NA, n.of.archive, n.of.archive-1)
X <- NULL
p.X <- NULL
y <- NULL
budget <- NULL
for (n in n.initial){
X <- rbind(X, n)
p.X <- rbind(p.X, n)
J <- stats::uniroot(function(J)
eval(pwr.expr) - power, Jlim)$root
m <- J *((1 - p) * c1 * n + p * c1t * n + c2)
J.m <- stats::uniroot(function(J)
eval(pwr2.expr) - (power-power.dis), Jlim)$root
m.m <- J.m *((1 - p) * c1 * n + p * c1t * n + c2)
m <- max(m, m.m)
y <- c(y, 1/m)
budget <- c(budget, m)
}
pp <- rbind(pp, data.frame(v = y, sd = 0, gr = 0, m = budget))
pp$gr <- rank(-pp$v, ties.method = "random")
for (i in 1:n.of.archive){
nl[i,] <- (1:n.of.archive)[1:n.of.archive!=i]
}
n.iter <- n.of.archive
if (verbose)
{cat('The ACO algorithm finished initilization of ',
n.of.archive, ' analyses',".\n", sep = "")}
while (TRUE) { # the algorithm will stop if one of the criteria is met
dist.mean <- p.X
if (sum(apply(dist.mean, 2, stats::sd)) < e) {
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = 1/max.y, p = par$p,
n = max.X,
J = 1/max.y/((1 - p) * c1 * n + p * c1t * n + c2))))
}
dist.rank <- pp$gr
dim(dist.mean) <- c(length(pp$v), n.of.opt.pars)
o.X <- vector()
o.X <- gen.design.pars(dist.mean, dist.rank,
n.of.ants, nl, q.aco, n.of.archive, xi)
if (length(o.X) == 0) {
m = 1/max.y; p = par$p; n = max.X;
J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- "n";
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
X <- NULL
for (i in 1:n.of.ants){ # exclude unreasonable values
if (sum((nrange[1] < o.X[i, 1]  && o.X[i, 1] < nrange[2])) == n.of.opt.pars) {
X <- rbind(X, o.X[i,])
}
}
if(length(X)>0) {
p.X <- rbind(p.X, X)
dim(X) <- c(length(X)/n.of.opt.pars, n.of.opt.pars)
for (j in 1:dim(X)[1]) {
# redo power analysis with n.of.ants times for those reasonable
n.iter <- n.iter + 1
n <- X[j, 1]
if (verbose) {
if(n.iter==n.of.archive+1){
cat('The number of iterations is ', n.iter, sep = "")
}else if((n.iter>n.of.archive+1)&(n.iter < max.iter)){
if (n.iter %in% c(seq(100, max.iter, by=100), max.iter)){
cat(n.iter,
" ", sep = "")
}else{
cat(".", sep = "")
}
}
}
J <- stats::uniroot(function(J)
eval(pwr.expr) - power, Jlim)$root
m <- J *((1 - p) * c1 * n + p * c1t * n + c2)
J.m <- stats::uniroot(function(J)
eval(pwr2.expr) - (power-power.dis), Jlim)$root
m.m <- J.m *((1 - p) * c1 * n + p * c1t * n + c2)
m <- max(m, m.m)
y <- c(y, 1/m)
budget <- c(budget, m)
pp <- rbind(pp, data.frame(v = 1/m, sd = 0, gr = 0, m = m))
}
}
# recalculate the rank
pp$gr <- rank(-pp$v, ties.method = "random")
idx.final <- pp$gr <= n.of.archive
pp <- pp[idx.final,]
p.X <- p.X[idx.final,]
y <- y[idx.final]
dim(p.X) <- c(length(p.X)/n.of.opt.pars, n.of.opt.pars)
for (i in 1:n.of.archive)
{nl[i,] <- (1:n.of.archive)[1:n.of.archive!=i]}
# check if the required accuracy have been obtained
if (max(y, na.rm = TRUE) > max.y) {
max.y <- max(y, na.rm = TRUE)
max.X <- p.X[which.max(y), ]
last.impr <- eval}
if ((abs(max.y - max.value) < abs(e.rel * max.value + e.abs)) |
(max.y > max.value)) {
m = 1/max.y; p = par$p; n = max.X;
J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- "n";
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
# check if the maximum allowed number of objective function
# evaluations has not been exceeded
if (n.iter >= max.iter) {
m = 1/max.y; p = par$p; n = max.X;
J = m/((1 - p) * c1 * n + p * c1t * n + c2);
colnames(p.X) <- "n";
return(list(archive = pp, archive.design.pars = p.X,
n.iter = n.iter, par = par, funName = funName,
designType = designType,
out = list(m = m, p = p, n = n,
J = J)))
}
}
} else if (!is.null(par$n) & !is.null(par$p)) {
cat("===============================\n",
"There is no optimization performed
because both p and n are contrained",
".\n===============================\n", sep = "")
J <- stats::uniroot(function(J)
eval(pwr.expr) - power, Jlim)$root
m <- J *((1 - p) * c1 * n + p * c1t * n + c2)
J.m <- stats::uniroot(function(J)
eval(pwr2.expr) - (power-power.dis), Jlim)$root
m.m <- J.m *((1 - p) * c1 * n + p * c1t * n + c2)
m <- max(m, m.m)
J <- max(J, J.m)
return(list(par = par, funName = funName,
designType = designType,
out = list(m = m,
p = par$p,
n = par$n, J = J)))
}
}
myod <- od.2m.111m(icc = .2, r12 = .5, r22m = .5,
c1 = 10, c1t = 100, c2 = 50, omega = .01, gamma = 0.1)
myod$out
#' Generate optimal design parameters using ant colony optimization
#'
#' @description This function can generate a set of optimal design parameters
#'     based on given distributions of the rank of optimization target
#'     (or budget).
#'
#' @inheritParams od.2.221
#' @param dist.mean List of means - coordinates
#' @param dist.rank Rank of the archived values of objective function
#' @param nl Neighborhood of the search area
#' @return
#'     Generated optimal design parameter value(s) (i.e., a matrix with n.of.ants
#'     rows and n.of.design.pars columns)
#'
#' @export gen.design.pars
#
#' @references
#'
#'   Socha, K., & Dorigo, M. (2008). Ant colony optimization for
#'   continuous domains. European Journal of Operational Research,
#'   185(3), 1155-1173.
#'
#'   We thank Dr. Krzysztof Socha for providing us the
#'   original code (http://iridia.ulb.ac.be/supp/IridiaSupp2008-001/)
#'   for this function.
gen.design.pars <- function(dist.mean, dist.rank, n.of.ants, nl,
q = 0.0001, n.of.archive = 100, xi = 0.50) {
euc.dist <- function(d) { # Euclidean distance
return(sqrt(sum(d^2)))
}
X <- array(dim = c(n.of.ants, dim(dist.mean)[2]))
idx <- sample(dim(dist.mean)[1], size = n.of.ants,
replace = TRUE, prob = stats::dnorm(dist.rank, 1, q*n.of.archive))
# iterate through the chosen distributions
for (l in 1:length(idx)) {
j <- idx[l]
# rotate the coordinate system
o.dist.mean <- t(t(dist.mean) - dist.mean[j,])  # translation of origin
r.dist.mean <- o.dist.mean
set <- nl[j,]  # set of available neighbors
vec <- vector()
for (m in 1:(dim(dist.mean)[2]-1)) {
dis <- apply(matrix(r.dist.mean[set,m:dim(r.dist.mean)[2]],
length(set),length(m:dim(r.dist.mean)[2])),1, euc.dist)
if (sum(dis)==0.0)  return(NULL) # if the distribution have converged
if (length(set)>1){ ## ADDED bracket
choice <- sample(set,size=1,prob=dis^4)
} else { ## ADDED bracket
choice <- set
}
vec <- cbind(vec,o.dist.mean[choice,])
R <- qr.Q(qr(vec), complete=TRUE) # rot. matrix after orthogonalization
if (det(R)<0) {
R[,1] <- -R[,1]
}
r.dist.mean <-  o.dist.mean %*% R # rotated coordinates
set <- set[set!=choice]
}
dist.sd <- vector()
for (i in 1:dim(dist.mean)[2]) {
dist.sd <- c(dist.sd,sum(abs(r.dist.mean[nl[j,],i]-
r.dist.mean[j,i]))/(n.of.archive-1))
}
n.x <- stats::rnorm(dim(dist.mean)[2],r.dist.mean[j,],dist.sd*xi)
n.x <- R %*% n.x
n.x <- t(n.x + dist.mean[j,])
X[l,] <- n.x
}
return(X)
}
myod <- od.2m.111m(icc = .2, r12 = .5, r22m = .5,
c1 = 10, c1t = 100, c2 = 50, omega = .01, gamma = 0.1)
myod$out
myod <- od.2m.111m(icc = .2, r12 = .5, r22m = .5,
c1 = 10, c1t = 100, c2 = 50, omega = .01, gamma = 0.1)
myod$out
myod <- od.2m.111m(icc = .2, r12 = .5, r22m = .5,
c1 = 10, c1t = 100, c2 = 50, omega = .01, gamma = 0.1)
